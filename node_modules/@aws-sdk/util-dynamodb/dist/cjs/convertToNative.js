"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertToNative = void 0;
const convertToNative = (data, options) => {
    for (const [key, value] of Object.entries(data)) {
        if (value !== undefined) {
            switch (key) {
                case "NULL":
                    return null;
                case "BOOL":
                    return Boolean(value);
                case "N":
                    return convertNumber(value, options);
                case "B":
                    return convertBinary(value);
                case "S":
                    return convertString(value);
                case "L":
                    return convertList(value, options);
                case "M":
                    return convertMap(value, options);
                case "NS":
                    return new Set(value.map((item) => convertNumber(item, options)));
                case "BS":
                    return new Set(value.map(convertBinary));
                case "SS":
                    return new Set(value.map(convertString));
                default:
                    throw new Error(`Unsupported type passed: ${key}`);
            }
        }
    }
    throw new Error(`No value defined: ${JSON.stringify(data)}`);
};
exports.convertToNative = convertToNative;
const convertNumber = (numString, options) => {
    if (options === null || options === void 0 ? void 0 : options.wrapNumbers) {
        return { value: numString };
    }
    const num = Number(numString);
    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];
    if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {
        if (typeof BigInt === "function") {
            try {
                return BigInt(numString);
            }
            catch (error) {
                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);
            }
        }
        else {
            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);
        }
    }
    return num;
};
const convertString = (stringValue) => stringValue;
const convertBinary = (binaryValue) => binaryValue;
const convertList = (list, options) => list.map((item) => exports.convertToNative(item, options));
const convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ({
    ...acc,
    [key]: exports.convertToNative(value, options),
}), {});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVydFRvTmF0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvbnZlcnRUb05hdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFXTyxNQUFNLGVBQWUsR0FBRyxDQUFDLElBQW9CLEVBQUUsT0FBMkIsRUFBd0IsRUFBRTtJQUN6RyxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMvQyxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDdkIsUUFBUSxHQUFHLEVBQUU7Z0JBQ1gsS0FBSyxNQUFNO29CQUNULE9BQU8sSUFBSSxDQUFDO2dCQUNkLEtBQUssTUFBTTtvQkFDVCxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDeEIsS0FBSyxHQUFHO29CQUNOLE9BQU8sYUFBYSxDQUFDLEtBQWUsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDakQsS0FBSyxHQUFHO29CQUNOLE9BQU8sYUFBYSxDQUFDLEtBQW1CLENBQUMsQ0FBQztnQkFDNUMsS0FBSyxHQUFHO29CQUNOLE9BQU8sYUFBYSxDQUFDLEtBQWUsQ0FBQyxDQUFDO2dCQUN4QyxLQUFLLEdBQUc7b0JBQ04sT0FBTyxXQUFXLENBQUMsS0FBeUIsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDekQsS0FBSyxHQUFHO29CQUNOLE9BQU8sVUFBVSxDQUFDLEtBQTBDLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQ3pFLEtBQUssSUFBSTtvQkFDUCxPQUFPLElBQUksR0FBRyxDQUFFLEtBQWtCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEYsS0FBSyxJQUFJO29CQUNQLE9BQU8sSUFBSSxHQUFHLENBQUUsS0FBc0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDN0QsS0FBSyxJQUFJO29CQUNQLE9BQU8sSUFBSSxHQUFHLENBQUUsS0FBa0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDekQ7b0JBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsR0FBRyxFQUFFLENBQUMsQ0FBQzthQUN0RDtTQUNGO0tBQ0Y7SUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUMvRCxDQUFDLENBQUM7QUE5QlcsUUFBQSxlQUFlLG1CQThCMUI7QUFFRixNQUFNLGFBQWEsR0FBRyxDQUFDLFNBQWlCLEVBQUUsT0FBMkIsRUFBaUMsRUFBRTtJQUN0RyxJQUFJLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxXQUFXLEVBQUU7UUFDeEIsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQztLQUM3QjtJQUVELE1BQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5QixNQUFNLGNBQWMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUM1RSxJQUFJLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ3JHLElBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxFQUFFO1lBQ2hDLElBQUk7Z0JBQ0YsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDMUI7WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDZCxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsU0FBUyw2RUFBNkUsQ0FBQyxDQUFDO2FBQzVHO1NBQ0Y7YUFBTTtZQUNMLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxTQUFTLCtFQUErRSxDQUFDLENBQUM7U0FDOUc7S0FDRjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQyxDQUFDO0FBR0YsTUFBTSxhQUFhLEdBQUcsQ0FBQyxXQUFtQixFQUFVLEVBQUUsQ0FBQyxXQUFXLENBQUM7QUFDbkUsTUFBTSxhQUFhLEdBQUcsQ0FBQyxXQUF1QixFQUFjLEVBQUUsQ0FBQyxXQUFXLENBQUM7QUFFM0UsTUFBTSxXQUFXLEdBQUcsQ0FBQyxJQUFzQixFQUFFLE9BQTJCLEVBQTBCLEVBQUUsQ0FDbEcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsdUJBQWUsQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUVyRCxNQUFNLFVBQVUsR0FBRyxDQUNqQixHQUFzQyxFQUN0QyxPQUEyQixFQUNjLEVBQUUsQ0FDM0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQ3hCLENBQUMsR0FBNEMsRUFBRSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQTJCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDekYsR0FBRyxHQUFHO0lBQ04sQ0FBQyxHQUFHLENBQUMsRUFBRSx1QkFBZSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUM7Q0FDdkMsQ0FBQyxFQUNGLEVBQUUsQ0FDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXR0cmlidXRlVmFsdWUgfSBmcm9tIFwiQGF3cy1zZGsvY2xpZW50LWR5bmFtb2RiXCI7XG5cbmltcG9ydCB7IE5hdGl2ZUF0dHJpYnV0ZVZhbHVlLCBOdW1iZXJWYWx1ZSB9IGZyb20gXCIuL21vZGVsc1wiO1xuaW1wb3J0IHsgdW5tYXJzaGFsbE9wdGlvbnMgfSBmcm9tIFwiLi91bm1hcnNoYWxsXCI7XG5cbi8qKlxuICogQ29udmVydCBhIER5bmFtb0RCIEF0dHJpYnV0ZVZhbHVlIG9iamVjdCB0byBpdHMgZXF1aXZhbGVudCBKYXZhU2NyaXB0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtBdHRyaWJ1dGVWYWx1ZX0gZGF0YSAtIFRoZSBEeW5hbW9EQiByZWNvcmQgdG8gY29udmVydCB0byBKYXZhU2NyaXB0IHR5cGUuXG4gKiBAcGFyYW0ge3VubWFyc2hhbGxPcHRpb25zfSBvcHRpb25zIC0gQW4gb3B0aW9uYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBjb252ZXJ0VG9OYXRpdmVgLlxuICovXG5leHBvcnQgY29uc3QgY29udmVydFRvTmF0aXZlID0gKGRhdGE6IEF0dHJpYnV0ZVZhbHVlLCBvcHRpb25zPzogdW5tYXJzaGFsbE9wdGlvbnMpOiBOYXRpdmVBdHRyaWJ1dGVWYWx1ZSA9PiB7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJOVUxMXCI6XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgXCJCT09MXCI6XG4gICAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgICAgICBjYXNlIFwiTlwiOlxuICAgICAgICAgIHJldHVybiBjb252ZXJ0TnVtYmVyKHZhbHVlIGFzIHN0cmluZywgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRCaW5hcnkodmFsdWUgYXMgVWludDhBcnJheSk7XG4gICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRTdHJpbmcodmFsdWUgYXMgc3RyaW5nKTtcbiAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICByZXR1cm4gY29udmVydExpc3QodmFsdWUgYXMgQXR0cmlidXRlVmFsdWVbXSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnRNYXAodmFsdWUgYXMgeyBba2V5OiBzdHJpbmddOiBBdHRyaWJ1dGVWYWx1ZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY2FzZSBcIk5TXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKHZhbHVlIGFzIHN0cmluZ1tdKS5tYXAoKGl0ZW0pID0+IGNvbnZlcnROdW1iZXIoaXRlbSwgb3B0aW9ucykpKTtcbiAgICAgICAgY2FzZSBcIkJTXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKHZhbHVlIGFzIFVpbnQ4QXJyYXlbXSkubWFwKGNvbnZlcnRCaW5hcnkpKTtcbiAgICAgICAgY2FzZSBcIlNTXCI6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQoKHZhbHVlIGFzIHN0cmluZ1tdKS5tYXAoY29udmVydFN0cmluZykpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBwYXNzZWQ6ICR7a2V5fWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYE5vIHZhbHVlIGRlZmluZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG59O1xuXG5jb25zdCBjb252ZXJ0TnVtYmVyID0gKG51bVN0cmluZzogc3RyaW5nLCBvcHRpb25zPzogdW5tYXJzaGFsbE9wdGlvbnMpOiBudW1iZXIgfCBiaWdpbnQgfCBOdW1iZXJWYWx1ZSA9PiB7XG4gIGlmIChvcHRpb25zPy53cmFwTnVtYmVycykge1xuICAgIHJldHVybiB7IHZhbHVlOiBudW1TdHJpbmcgfTtcbiAgfVxuXG4gIGNvbnN0IG51bSA9IE51bWJlcihudW1TdHJpbmcpO1xuICBjb25zdCBpbmZpbml0eVZhbHVlcyA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV07XG4gIGlmICgobnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbnVtIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpICYmICFpbmZpbml0eVZhbHVlcy5pbmNsdWRlcyhudW0pKSB7XG4gICAgaWYgKHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW1TdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke251bVN0cmluZ30gY2FuJ3QgYmUgY29udmVydGVkIHRvIEJpZ0ludC4gU2V0IG9wdGlvbnMud3JhcE51bWJlcnMgdG8gZ2V0IHN0cmluZyB2YWx1ZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke251bVN0cmluZ30gaXMgb3V0c2lkZSBTQUZFX0lOVEVHRVIgYm91bmRzLiBTZXQgb3B0aW9ucy53cmFwTnVtYmVycyB0byBnZXQgc3RyaW5nIHZhbHVlLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtO1xufTtcblxuLy8gRm9yIGZ1dHVyZS1wcm9vZmluZzogRnVuY3Rpb25zIGZyb20gc2NhbGFyIHZhbHVlIGFzIHdlbGwgYXMgc2V0IHZhbHVlXG5jb25zdCBjb252ZXJ0U3RyaW5nID0gKHN0cmluZ1ZhbHVlOiBzdHJpbmcpOiBzdHJpbmcgPT4gc3RyaW5nVmFsdWU7XG5jb25zdCBjb252ZXJ0QmluYXJ5ID0gKGJpbmFyeVZhbHVlOiBVaW50OEFycmF5KTogVWludDhBcnJheSA9PiBiaW5hcnlWYWx1ZTtcblxuY29uc3QgY29udmVydExpc3QgPSAobGlzdDogQXR0cmlidXRlVmFsdWVbXSwgb3B0aW9ucz86IHVubWFyc2hhbGxPcHRpb25zKTogTmF0aXZlQXR0cmlidXRlVmFsdWVbXSA9PlxuICBsaXN0Lm1hcCgoaXRlbSkgPT4gY29udmVydFRvTmF0aXZlKGl0ZW0sIG9wdGlvbnMpKTtcblxuY29uc3QgY29udmVydE1hcCA9IChcbiAgbWFwOiB7IFtrZXk6IHN0cmluZ106IEF0dHJpYnV0ZVZhbHVlIH0sXG4gIG9wdGlvbnM/OiB1bm1hcnNoYWxsT3B0aW9uc1xuKTogeyBba2V5OiBzdHJpbmddOiBOYXRpdmVBdHRyaWJ1dGVWYWx1ZSB9ID0+XG4gIE9iamVjdC5lbnRyaWVzKG1hcCkucmVkdWNlKFxuICAgIChhY2M6IHsgW2tleTogc3RyaW5nXTogTmF0aXZlQXR0cmlidXRlVmFsdWUgfSwgW2tleSwgdmFsdWVdOiBbc3RyaW5nLCBBdHRyaWJ1dGVWYWx1ZV0pID0+ICh7XG4gICAgICAuLi5hY2MsXG4gICAgICBba2V5XTogY29udmVydFRvTmF0aXZlKHZhbHVlLCBvcHRpb25zKSxcbiAgICB9KSxcbiAgICB7fVxuICApO1xuIl19